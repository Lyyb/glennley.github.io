<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/glennley.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/glennley.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/glennley.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/glennley.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/glennley.github.io/css/main.css">


<link rel="stylesheet" href="/glennley.github.io/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/glennley.github.io/lib/pace/pace-theme-minimal.min.css">
  <script src="/glennley.github.io/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lyyb.github.io","root":"/glennley.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="GlennLey&#39;s Blog">
<meta property="og:url" content="https://lyyb.github.io/glennley.github.io/index.html">
<meta property="og:site_name" content="GlennLey&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="GlennLey">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://lyyb.github.io/glennley.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>GlennLey's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/glennley.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">GlennLey's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-begin">

    <a href="/glennley.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Begin</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://lyyb.github.io/glennley.github.io/2021/06/06/this-point/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/glennley.github.io/images/WechatIMG12.jpeg">
      <meta itemprop="name" content="GlennLey">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GlennLey's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/glennley.github.io/2021/06/06/this-point/" class="post-title-link" itemprop="url">浅谈this 指向</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-06 23:54:39" itemprop="dateCreated datePublished" datetime="2021-06-06T23:54:39+08:00">2021-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-07 00:14:26" itemprop="dateModified" datetime="2021-06-07T00:14:26+08:00">2021-06-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>写在前面</strong></p>
<p>谈到this，我们经常为之头疼，其实把规则捋清楚了！你会发现其实并没有想象的那么难！</p>
<p><strong>常见场景</strong></p>
<ol>
<li><p>普通函数的this：指向它的调用者，如果没有调用者则默认指向window。</p>
</li>
<li><p>箭头函数的this: 指向箭头函数定义时所处的对象，而不是箭头函数使用时所在的对象，默认使用父级的this。</p>
</li>
<li><p>this的指向在函数定义的时候是无法确定的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。</p>
</li>
<li><p>构造函数里面的 this 会绑定到我们 new 出来的这个对象上：默认绑定的指向。</p>
</li>
</ol>
<p><strong>关于权重</strong></p>
<p>bind的权重比call和apply高！！</p>
<p>权重最高：new！</p>
<p><strong>在浏览器和Node中的区别</strong><br>在浏览器中，指向 window；在 Node 中，指向 Global。（严格模式下，指向 undefined）</p>
<p>在三种特殊情境下，this 会 100% 指向 window：<br>立即执行函数（IIFE）</p>
<p><strong>补充形成IIFE的常见方法</strong></p>
<ol>
<li>函数不能直接加圆括号调用。</li>
<li>函数必须转为函数表达式才能被调用</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123; alert(1); &#125;)();</span><br><span class="line">!function()&#123; alert(1); &#125;();</span><br><span class="line">+function()&#123; alert(1); &#125;();</span><br><span class="line">-function()&#123; alert(1); &#125;();</span><br><span class="line">~function()&#123; alert(1); &#125;();</span><br></pre></td></tr></table></figure>

<p>setTimeout 中传入的函数<br>setInterval 中传入的函数</p>
<p>在严格模式下，this 将保持它被指定的那个对象的值，所以，如果没有指定对象，this 就是 undefined</p>
<p><strong>call、apply、bind</strong></p>
<p>改变函数的this指向</p>
<ol>
<li><p>改变后直接进行函数调用<br>call<br>apply</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.call(target, arg1, arg2)</span><br><span class="line">fn.apply(target, [arg1, arg2])</span><br></pre></td></tr></table></figure>
<p>call 和 apply 之间的区别，则体现在对入参的要求上。<br>前者只需要将目标函数的入参逐个传入即可，后者则希望入参以数组形式被传入。</p>
</li>
<li><p>仅仅改变，不执行</p>
</li>
</ol>
<p>bind</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.bind(target, arg1, arg2 )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只是需要注意的是使用bind如果需要执行，需要加上调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn.bind(target, arg1, arg2 )()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://lyyb.github.io/glennley.github.io/2021/06/06/javascriptCycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/glennley.github.io/images/WechatIMG12.jpeg">
      <meta itemprop="name" content="GlennLey">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GlennLey's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/glennley.github.io/2021/06/06/javascriptCycle/" class="post-title-link" itemprop="url">JavaScript 代码运行的各个阶段(生命周期)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-06-06 23:33:00 / Modified: 23:46:48" itemprop="dateCreated datePublished" datetime="2021-06-06T23:33:00+08:00">2021-06-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>写在前面</strong></p>
<p>JavaScript 是弱类型语言，在运行时才能确定变量类型。即使是如今流行的 TypeScript，也只是增加了编译时（编译成 JavaScript）的类型检测（对于编译器相信大家都有所了解，代码编译过程中编译器会进行词法分析、语法分析、语义分析、生成 AST 等处理）。</p>
<p>同样，JavaScript 引擎在执行 JavaScript 代码时，也会从上到下进行词法分析、语法分析、语义分析等处理，并在代码解析完成后生成 AST（抽象语法树），最终根据 AST 生成 CPU 可以执行的机器码并执行。</p>
<p>这个过程，我们后面统一描述为语法分析阶段。除了语法分析阶段，JavaScript 引擎在执行代码时还会进行其他的处理。以 V8 引擎为例，在 V8 引擎中 JavaScript 代码的运行过程主要分成三个阶段。</p>
<ol>
<li><p>语法分析阶段。<br>该阶段会对代码进行语法分析，检查是否有语法错误（SyntaxError），如果发现语法错误，会在控制台抛出异常并终止执行。</p>
</li>
<li><p>编译阶段。<br>该阶段会进行执行上下文（Execution Context）的创建，包括创建变量对象、建立作用域链、确定 this 的指向等。每进入一个不同的运行环境时，V8 引擎都会创建一个新的执行上下文。</p>
</li>
<li><p>执行阶段。<br>将编译阶段中创建的执行上下文压入调用栈，并成为正在运行的执行上下文，代码执行结束后，将其弹出调用栈。</p>
</li>
</ol>
<p>其中，语法分析阶段属于编译器通用内容，就不再赘述。前面提到的执行环境、词法环境、作用域、执行上下文等内容都是在编译和执行阶段中产生的概念。</p>
<p>JavaScript 在运行过程中会产生一个调用栈，调用栈遵循 LIFO（先进后出，后进先出）原则即可。</p>
<p><strong>执行上下文的创建</strong></p>
<p>执行上下文的创建离不开 JavaScript 的运行环境，JavaScript 运行环境包括全局环境、函数环境和eval，其中全局环境和函数环境的创建过程如下：</p>
<p>第一次载入 JavaScript 代码时，首先会创建一个全局环境。全局环境位于最外层，直到应用程序退出后（例如关闭浏览器和网页）才会被销毁。</p>
<p>每个函数都有自己的运行环境，当函数被调用时，则会进入该函数的运行环境。当该环境中的代码被全部执行完毕后，该环境会被销毁。不同的函数运行环境不一样，即使是同一个函数，在被多次调用时也会创建多个不同的函数环境。</p>
<p>在不同的运行环境中，变量和函数可访问的其他数据范围不同，环境的行为（比如创建和销毁）也有所区别。而每进入一个不同的运行环境时，JavaScript 都会创建一个新的执行上下文，该过程包括</p>
<ol>
<li><p>建立作用域链（Scope Chain）；</p>
</li>
<li><p>创建变量对象（Variable Object，简称 VO）；</p>
</li>
<li><p>确定 this 的指向。</p>
</li>
</ol>
<p>由于建立作用域链过程中会涉及变量对象的概念，因此我们先来看看变量对象的创建，再看建立作用域链和确定 this 的指向。</p>
<p>在全局环境中，this指向全局对象（在浏览器中为window）</p>
<p>在函数内部，this的值取决于函数被调用的方式</p>
<p>函数作为对象的方法被调用，this指向调用这个方法的对象</p>
<p>函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象</p>
<p>在类的构造函数中，this是一个常规对象，类中所有非静态的方法都会被添加到this的原型中</p>
<p>在箭头函数中，this指向它被创建时的环境</p>
<p>使用apply、call、bind等方式调用：根据 API 不同，可切换函数执行的上下文环境，即this绑定的对象</p>
<p>可以看到，this在不同的情况下会有不同的指向，在 ES6 箭头函数还没出现之前，为了能正确获取某个运行环境下this对象，我们常常会使用var that = this;、var self = this;这样的代码将变量分配给this，便于使用。这种方式降低了代码可读性，因此如今这种做法不再被提倡，通过正确使用箭头函数，我们可以更好地管理作用域。</p>
<p><strong>创建变量对象</strong></p>
<p>什么是变量对象呢？每个执行上下文都会有一个关联的变量对象，该对象上会保存这个上下文中定义的所有变量和函数。</p>
<p>而在浏览器中，全局环境的变量对象是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。相应的，在 Node 中全局环境的变量对象则是global对象。</p>
<p>对于变量声明：此时会给变量分配内存，并将其初始化为undefined（该过程只进行定义声明，执行阶段才执行赋值语句）。</p>
<p>对于函数声明：此时会在内存里创建函数对象，并且直接初始化为该函数对象。</p>
<p>上述变量声明和函数声明的处理过程，便是我们常说的变量提升和函数提升，其中函数声明提升会优先于变量声明提升。因为变量提升容易带来变量在预期外被覆盖掉的问题，同时还可能导致本应该被销毁的变量没有被销毁等情况。因此 ES6 中引入了let和const关键字，从而使 JavaScript 也拥有了块级作用域。</p>
<p>或许你会感到疑惑，JavaScript 是怎么支持块级作用域的呢？这就涉及作用域的概念。</p>
<p>在各类编程语言中，作用域分为静态作用域和动态作用域。JavaScript 采用的是词法作用域（Lexical Scoping），也就是静态作用域。词法作用域中的变量，在编译过程中会产生一个确定的作用域。</p>
<p>到这里，或许你对会词法作用域、作用域、执行上下文、词法环境之间的关系依然感到混乱，没关系，一起梳理梳理下。</p>
<p>上述提到，词法作用域中的变量，在编译过程中会产生一个确定的作用域，这个作用域即当前的执行上下文，在 ES5 后我们使用词法环境（Lexical Environment）替代作用域来描述该执行上下文。因此，词法环境可理解为我们常说的作用域，同样也指当前的执行上下文（注意，是当前的执行上下文）。</p>
<p>在 JavaScript 中，词法环境又分为词法环境（Lexical Environment）和变量环境（Variable Environment）两种，其中：</p>
<ol>
<li><p>变量环境用来记录var/function等变量声明；</p>
</li>
<li><p>词法环境是用来记录let/const/class等变量声明。</p>
</li>
</ol>
<p>也就是说，创建变量过程中会进行函数提升和变量提升，JavaScript 会通过词法环境来记录函数和变量声明。通过使用两个词法环境（而不是一个）分别记录不同的变量声明内容，JavaScript 实现了支持块级作用域的同时，不影响原有的变量声明和函数声明。</p>
<p>这就是创建变量的过程，它属于执行上下文创建中的一环。创建变量的过程会产生作用域，作用域也被称为词法环境，那词法环境是由什么组成的呢？下面我结合作用域链的建立过程一起来进行分析。</p>
<p><strong>建立作用域链</strong></p>
<p>作用域链，顾名思义，就是将各个作用域通过某种方式连接在一起。</p>
<p>作用域就是词法环境，而词法环境由两个成员组成。</p>
<p>环境记录（Environment Record）：用于记录自身词法环境中的变量对象。</p>
<p>外部词法环境引用（Outer Lexical Environment）：记录外层词法环境的引用。</p>
<p>通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。</p>
<p>那么，这个外部词法环境引用又是怎样指向外层呢？我们来看看 JavaScript 中是如何通过外部词法环境引用来创建作用域的。</p>
<p>为了方便描述，我们将 JavaScript 代码运行过程分为定义期和执行期，前面提到的编译阶段则属于定义期。</p>
<p>在定义期（编译阶段）：该对象值仍为undefined，且处于不可访问的状态。</p>
<p>进入执行期（执行阶段）：VO 被激活，其中变量属性会进行赋值。</p>
<p>实际上在执行的时候，除了 VO 被激活，活动对象还会添加函数执行时传入的参数和arguments这个特殊对象</p>
<p>从当前词法环境开始，沿着作用域链逐级向外层寻找环境记录，直到找到同名变量为止；</p>
<p>找到后不再继续遍历，找不到就报错。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://lyyb.github.io/glennley.github.io/2021/06/06/variable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/glennley.github.io/images/WechatIMG12.jpeg">
      <meta itemprop="name" content="GlennLey">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GlennLey's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/glennley.github.io/2021/06/06/variable/" class="post-title-link" itemprop="url">变量提升与暂时性死区</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-06-06 23:06:20 / Modified: 23:43:02" itemprop="dateCreated datePublished" datetime="2021-06-06T23:06:20+08:00">2021-06-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>从变量提升说起</strong></p>
<p>在 ES5的“var” 时代，有一个特别的现象：不管我们的变量声明是写在程序的哪个角落，最后都会被提到作用域的顶端去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(num)   //undefined</span><br><span class="line">var num = 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>神奇的变量提升</strong></p>
<p>这段代码不会报错，反而会输出一个 undefined。这就是因为变量的声明被“提升”了，它等价于这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var num</span><br><span class="line">console.log(num)  // undefined</span><br><span class="line">num = 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这个例子里，我们看到 num 作为全局变量会被提升到全局作用域的头部。在函数作用域里，也会有类似的现象发生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getNum() &#123;</span><br><span class="line">  console.log(num) </span><br><span class="line">  var num = 1  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里同样会输出 undefined，这是因为函数内部的变量声明会被提升至函数作用域的顶端。上面这个例子其实等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getNum() &#123;</span><br><span class="line">  var num </span><br><span class="line">  console.log(num) </span><br><span class="line">  num = 1  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>变量提升的原理</strong></p>
<p>事实上，JS也是有编译阶段的，它和传统语言的区别在于，JS不会早早地把编译工作做完，而是一边编译一边执行。简单来说，所有的JS代码片段在执行之前都会被编译，只是这个编译的过程非常短暂（可能就只有几微妙、或者更短的时间），紧接着这段代码就会被执行。</p>
<p>没错，JS 和其他语言一样，都要经历编译和执行阶段。正是在这个短暂的编译阶段里，JS 引擎会搜集所有的变量声明，并且提前让声明生效。至于剩下的语句，则需要等到执行阶段、等到执行到具体的某一句的时候才会生效。这就是变量提升背后的机制。</p>
<p><strong>被禁用的变量提升 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(num) </span><br><span class="line">let num = 1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VM324:1 Uncaught ReferenceError: num is not defined</span><br><span class="line">    at &lt;anonymous&gt;:1:13</span><br></pre></td></tr></table></figure>

<p>理解 let 的时候可以参考 var。let 和 var 非常相似，<br>let 区别于 var 的最关键的地方在于：当我们用 let 声明变量时<br>，变量会被绑定到块作用域上，而 var 是不感知块作用域的。</p>
<p>值得注意的是，这个规则在声明引用类型时有点不同——引用类型的属性值<br>（包括数组的元素）可以被更改，只要你不修改引用的指向。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const me = &#123;</span><br><span class="line">  name: &#x27;Glennley&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">me.name = &#x27;Bear&#x27; // 没问题</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>像这样修改 name 这个属性值，而 me 对象的引用仍然指向<br>原有的内存地址，这种更改就可以被接受。而类似这种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const me = &#123;</span><br><span class="line">  name: &#x27;Glennley&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">me = &#123;</span><br><span class="line">  name: &#x27;Bear&#x27;</span><br><span class="line">&#125; // 报错</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,2,3,4]</span><br><span class="line">arr.push(2)</span><br><span class="line"> // arr [1, 2, 3, 4, 2]</span><br><span class="line">arr.slice(0,1)  //该方法不会改变原数组，而是返回一个子数组</span><br><span class="line">[1]  //返回</span><br><span class="line">arr.splice(0,1) //该方法向或者从数组中添加或者删除项目</span><br><span class="line">//返回被删除的项目。（该方法会改变原数组）</span><br><span class="line">[1]</span><br><span class="line">[2, 3, 4, 2]</span><br><span class="line">const arrObj = &#123;a:1,b:2&#125;</span><br><span class="line">arrObj.a = 2</span><br><span class="line">2</span><br><span class="line">arrObj.d = &#x27;c:3&#x27;</span><br><span class="line">&quot;c:3&quot;</span><br><span class="line">arrObj</span><br><span class="line">&#123;a: 2, b: 2, d: &quot;c:3&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong> 暂时性死区 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var me = &#x27;glennley&#x27;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	me = &#x27;bear&#x27;;</span><br><span class="line">	let me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样的代码也经常作为面试题来出。<br>面试官会问你：这段代码的运行结果是啥？ 事实上，<br>这段代码啥也运行不出来，它会报错：</p>
<p>这是因为 ES6 中有明确的规定：如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。假如我们尝试在声明前去使用这类变量，就会报错。<br>这一段会报错的危险区域，有一个专属的名字，叫”暂时性死区“。在下面 demo 中，me = ‘glennley’  区域就是暂时性死区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    me = &#x27;glennley&#x27;   //即暂时性死区</span><br><span class="line">    let me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://lyyb.github.io/glennley.github.io/2021/06/01/function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/glennley.github.io/images/WechatIMG12.jpeg">
      <meta itemprop="name" content="GlennLey">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GlennLey's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/glennley.github.io/2021/06/01/function/" class="post-title-link" itemprop="url">普通函数和构造函数的本质区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-01 23:46:43" itemprop="dateCreated datePublished" datetime="2021-06-01T23:46:43+08:00">2021-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-02 00:08:27" itemprop="dateModified" datetime="2021-06-02T00:08:27+08:00">2021-06-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>可能很多刚入门的小伙伴对于普通函数和构造函数之间的区别,一直分不清</strong><br>那么我们就来捋一捋他们之间的本质区别在哪？</p>
<ol>
<li>构造函数也是一个普通函数，在创建方式上和普通函数一样，只是构造函数通常首字母都是大写</li>
<li>调用方式不一样，普通函数直接调用，构造函数要用关键字new来调用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function fn() &#123; &#125;</span><br><span class="line">    // 构造函数：1. new fn( )</span><br><span class="line">                    // 2 .构造函数(constructor)内部会创建一个新的对象，即f的实例</span><br><span class="line">                    // 3. 函数内部的this指向 新创建的f的实例</span><br><span class="line">                   //  4. 默认的返回值是f的实例</span><br><span class="line">    // 普通函数：1. fn( )</span><br><span class="line">                   //  2. 在调用函数的内部不会创建新的对象</span><br><span class="line">                   //  3. 函数内部的this指向调用函数的对象（如果没有对象调用，默认是window）</span><br><span class="line">                  //   4. 返回值由return语句决定</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="3">
<li><p>调用时，构造函数内部会创建一个新对象，就是实例，普通函数不会创建新对象<br>构造函数的返回值：<br>  有一个默认的返回值，新创建的对象（实例）；<br>  当手动添加返回值后（return语句）：</p>
<pre><code>   1. 返回值是基本数据类型 --&gt;真正的返回值还是那个新创建的对象（实例）
   2. 返回值是复杂数据类型（对象）--&gt;真正的返回值是这个对象
</code></pre>
</li>
<li><p>构造函数内部的this指向实例，普通函数内部的this指向调用函数的对象（如果没有对象调用，默认为window）</p>
</li>
<li><p>构造函数默认的返回值是创建的对象（也就是实例），普通函数的返回值由return语句决定</p>
</li>
<li><p>构造函数的函数名与类名相同</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://lyyb.github.io/glennley.github.io/2021/06/01/Vue-data/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/glennley.github.io/images/WechatIMG12.jpeg">
      <meta itemprop="name" content="GlennLey">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GlennLey's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/glennley.github.io/2021/06/01/Vue-data/" class="post-title-link" itemprop="url">为什么Vue中data必须是一个函数而不是对象？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-06-01 23:35:09 / Modified: 23:44:36" itemprop="dateCreated datePublished" datetime="2021-06-01T23:35:09+08:00">2021-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong> 写在前面 </strong><br>可能很多小伙伴在面试的时候,经常有被问到为什么Vue中data必须是一个函数而不是对象？<br>emmmm…<br>其实答案并没有我们想的那么复杂…为什么呢？<br>为什么是这样子？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>而不是这样子呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data : &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实不难发现…</p>
<p>Vue中data是可以写成对象的,前提是要保证这个组件是不会被复用的,<br>我们都知道模块化开发,在这种场景下,由于组件的复用,其实我们可以理解成创建了多个Vue实例,<br>如果data中只是个对象,那么创建出来的实例都是同一个对象的引用。<br>简而言之，多个组件复用时，每次调用data函数的时候都会return一个新的对象，它们的内存地址都是不一样的，这样就不会相互影响。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://lyyb.github.io/glennley.github.io/2021/06/01/vue-template-compiler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/glennley.github.io/images/WechatIMG12.jpeg">
      <meta itemprop="name" content="GlennLey">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GlennLey's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/glennley.github.io/2021/06/01/vue-template-compiler/" class="post-title-link" itemprop="url">浅谈vue模板编译（template）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-01 21:53:11" itemprop="dateCreated datePublished" datetime="2021-06-01T21:53:11+08:00">2021-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-03 15:40:52" itemprop="dateModified" datetime="2021-06-03T15:40:52+08:00">2021-06-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>写在前面<br> 起初上手的技术栈是Vue2.0, 而且工作中使用的技术栈也是Vue(2.0),空闲之余便会花时间去深入了解一些关于Vue的底层原理，并做出一些总结。</p>
<p> 如果理解上存在偏差,还请指正~ 一起学习,一起进步!</p>
</li>
</ul>
<ul>
<li>开始上手</li>
</ul>
<p> <strong>在此之前我们要理解什么是AST？</strong></p>
<p>  在计算机当中, 抽象语法树便是(Abstract Syntax Tree 缩写为AST),也可以理解成语法树(Syntax Tree), AST经过generate之后会得到render函数,而render函数返回的是Vnode,<br>  因此 Vnode便是Vue的虚拟DOM节点。</p>
<ul>
<li>初识compiler<br>平时我们使用vue-cli创建项目的时候，经常性会在package.json中看到 “devDependencies”里面配置项，有 “@vue/compiler-sfc”: “^3.0.0”的配置项<br>那么我们就用它来测试一下,template文件被编译过后是什么样子呢？<br><strong>通过以下操作<strong></li>
</ul>
<ol>
<li>首先我们需要创建一个文件夹,可手动创建也可通过mkdir的方式创建,接着我们把文件夹在终端中打开,推荐使用vscode工具,因为在vscode中集成了powershell（shell指令）。</li>
<li>cd选择我们所创建出来的文件夹 cd 文件夹名字</li>
<li>输入npm init -y（-y可省略对package.json的描述 默认）</li>
<li>在当前文件夹新建index.js  也可以使用命令的方式 touch  index.js  (新建index.js)</li>
<li>使用 npm i vue-template-compiler –save  /  npm install  vue-template-compiler -S</li>
<li>在index.js 文件中引入 vue-template-compiler  const compiler = require(‘vue-template-compiler ‘)<ul>
<li>index.js<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">const compiler = require(&#x27;vue-template-compiler&#x27;)</span><br><span class="line"></span><br><span class="line">// 插值</span><br><span class="line">// const template = `&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;`</span><br><span class="line">// with(this)&#123;return createElement(&#x27;p&#x27;,[createTextVNode(toString(message))])&#125;</span><br><span class="line">// h -&gt; vnode</span><br><span class="line">// createElement -&gt; vnode</span><br><span class="line"></span><br><span class="line">// // 表达式</span><br><span class="line">// const template = `&lt;p&gt;&#123;&#123;flag ? message : &#x27;no message found&#x27;&#125;&#125;&lt;/p&gt;`</span><br><span class="line">// // with(this)&#123;return _c(&#x27;p&#x27;,[_v(_s(flag ? message : &#x27;no message found&#x27;))])&#125;</span><br><span class="line"></span><br><span class="line">// // 属性和动态属性</span><br><span class="line">// const template = `</span><br><span class="line">//     &lt;div id=&quot;div1&quot; class=&quot;container&quot;&gt;</span><br><span class="line">//         &lt;img :src=&quot;imgUrl&quot;/&gt;</span><br><span class="line">//     &lt;/div&gt;</span><br><span class="line">// `</span><br><span class="line">// with(this)&#123;return _c(&#x27;div&#x27;,</span><br><span class="line">//      &#123;staticClass:&quot;container&quot;,attrs:&#123;&quot;id&quot;:&quot;div1&quot;&#125;&#125;,</span><br><span class="line">//      [</span><br><span class="line">//          _c(&#x27;img&#x27;,&#123;attrs:&#123;&quot;src&quot;:imgUrl&#125;&#125;)])&#125;</span><br><span class="line"></span><br><span class="line">// // 条件</span><br><span class="line">// const template = `</span><br><span class="line">//     &lt;div&gt;</span><br><span class="line">//         &lt;p v-if=&quot;flag === &#x27;a&#x27;&quot;&gt;A&lt;/p&gt;</span><br><span class="line">//         &lt;p v-else&gt;B&lt;/p&gt;</span><br><span class="line">//     &lt;/div&gt;</span><br><span class="line">// `</span><br><span class="line">// with(this)&#123;return _c(&#x27;div&#x27;,[(flag === &#x27;a&#x27;)?_c(&#x27;p&#x27;,[_v(&quot;A&quot;)]):_c(&#x27;p&#x27;,[_v(&quot;B&quot;)])])&#125;</span><br><span class="line"></span><br><span class="line">// 循环</span><br><span class="line">// const template = `</span><br><span class="line">//     &lt;ul&gt;</span><br><span class="line">//         &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/li&gt;</span><br><span class="line">//     &lt;/ul&gt;</span><br><span class="line">// `</span><br><span class="line">// with(this)&#123;return _c(&#x27;ul&#x27;,_l((list),function(item)&#123;return _c(&#x27;li&#x27;,&#123;key:item.id&#125;,[_v(_s(item.title))])&#125;),0)&#125;</span><br><span class="line"></span><br><span class="line">// 事件</span><br><span class="line">// const template = `</span><br><span class="line">//     &lt;button @click=&quot;clickHandler&quot;&gt;submit&lt;/button&gt;</span><br><span class="line">// `</span><br><span class="line">// with(this)&#123;return _c(&#x27;button&#x27;,&#123;on:&#123;&quot;click&quot;:clickHandler&#125;&#125;,[_v(&quot;submit&quot;)])&#125;</span><br><span class="line"></span><br><span class="line">// v-model</span><br><span class="line">const template = `&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;`</span><br><span class="line">// 主要观察 input 事件</span><br><span class="line">// with(this)&#123;return _c(&#x27;input&#x27;,&#123;directives:[&#123;name:&quot;model&quot;,rawName:&quot;v-model&quot;,value:(name),expression:&quot;name&quot;&#125;],attrs:&#123;&quot;type&quot;:&quot;text&quot;&#125;,domProps:&#123;&quot;value&quot;:(name)&#125;,on:&#123;&quot;input&quot;:function($event)&#123;if($event.target.composing)return;name=$event.target.value&#125;&#125;&#125;)&#125;</span><br><span class="line"></span><br><span class="line">// render 函数</span><br><span class="line">// 返回 vnode</span><br><span class="line">// patch</span><br><span class="line"></span><br><span class="line">// 编译</span><br><span class="line">const res = compiler.compile(template)</span><br><span class="line">console.log(res.render)</span><br><span class="line"></span><br><span class="line">// ---------------分割线--------------</span><br><span class="line"></span><br><span class="line">// // 从 vue 源码中找到缩写函数的含义</span><br><span class="line"> function installRenderHelpers (target) &#123;</span><br><span class="line">    target._o = markOnce // v-once render 处理</span><br><span class="line">    target._n = toNumber // 值转换 Number 处理</span><br><span class="line">    target._s = toString // 值转换 String 处理</span><br><span class="line">    target._l = renderList // v-for render 处理</span><br><span class="line">    target._t = renderSlot // slot 槽点 render 处理</span><br><span class="line">    target._q = looseEqual // 判断两个对象是否大体相等</span><br><span class="line">    target._i = looseIndexOf // 对等属性索引，不存在则返回 -1</span><br><span class="line">    target._m = renderStatic // 静态节点 render 处理</span><br><span class="line">    target._f = resolveFilter // filters 指令 render 处理</span><br><span class="line">    target._k = checkKeyCodes // checking keyCodes from config</span><br><span class="line">    target._b = bindObjectProps // v-bind render 处理，将 v-bind=&quot;object&quot; 的属性 merge 到VNode属性中</span><br><span class="line">    target._v = createTextVNode // 创建文本节点</span><br><span class="line">    target._e = createEmptyVNode // 创建空节点</span><br><span class="line">    target._u = resolveScopedSlots // scopeSlots render 处理</span><br><span class="line">    target._g = bindObjectListeners // v-on render 处理</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在终端中输入 node index.js 这个时候我们便可以在终端看到template被编译过后的代码</li>
</ol>
<ul>
<li>编译过后的代码<br>通过打印出来的代码,我们可以得出结论,会看到一个with, 关于这个with我们大部分人或许没有见到过这个奇怪的用法,<br>但是在对作用域修改的时候,我们便会用到 with.<br><strong>举个例子</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  var me = &#123;</span><br><span class="line">  name: &#x27;glennley&#x27;,</span><br><span class="line">  career: &#x27;coder&#x27;,</span><br><span class="line">  hobbies: [&#x27;coding&#x27;, &#x27;football&#x27;]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
假如我们想输出对象 me 中的变量，没有 with 可能会这样做：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(me.name)</span><br><span class="line">console.log(me.career)</span><br><span class="line">console.log(me.hobbies)</span><br></pre></td></tr></table></figure>
但with 可以帮助我们省去写前缀的时间</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with(me) &#123;</span><br><span class="line">console.log(name)</span><br><span class="line">console.log(career)</span><br><span class="line">console.log(hobbies)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  没错， with 就是当我们希望去引用一个对象内的多个属性的时候，一个 “偷懒” 的办法。</p>
<p>  为什么说 with 可以 “改变” 词法作用域呢？我们再来看一个例子：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function changeName(person) &#123;</span><br><span class="line">with(person) &#123;</span><br><span class="line">    name = &#x27;GlennLey&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var me = &#123;</span><br><span class="line">name: &#x27;GlennLey&#x27;,</span><br><span class="line">career: &#x27;coder&#x27;,</span><br><span class="line">hobbies: [&#x27;coding&#x27;, &#x27;footbal&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var you = &#123;</span><br><span class="line">career: &#x27;product manager&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeName(me)</span><br><span class="line">changeName(you)</span><br><span class="line">console.log(name) // 输出 &#x27;GlennLey&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>with 会原地创建一个全新的作用域，这个作用域内的变量集合，其实就是传入 with 的目标对象的属性集合。<br>因为 “创建” 这个动作，是在 with 代码实际已经被执行后发生的，所以这个新作用域确实是在运行时被添加的， with 因此也实现了对书写阶段就划分好的作用域进行修改。</p>
<p>注意， with 对作用域的改变，仅仅在于 “创建” 这个动作。当这个作用域被创建出来之后，它的查询规则仍然遵循我们词法作用域的查询规则，所以它本能地 “探出头去”、去自己的上层作用域 —— 全局作用域查询</p>
<p>tips：不要用 with 和 eval 写代码!!!<br>事实上， with 和 eval 因为其恼人的副作用（比如对语言性能的拖累、比如我们上面 “横空出世” 的全局变量等等），一直是我们 JS 程序员眼中的过街老鼠。实际编码中早就没人用了，我也极力推荐大家不要用。</p>
<p><strong>写在最后</strong></p>
<p>通过模板编译之后,render函数最终会返回一个Vnode节点,在更新的时候,经过patch与之前的Vnode节点进行比较,最终将差异渲染到真实的DOM上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://lyyb.github.io/glennley.github.io/2021/05/27/typeof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/glennley.github.io/images/WechatIMG12.jpeg">
      <meta itemprop="name" content="GlennLey">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GlennLey's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/glennley.github.io/2021/05/27/typeof/" class="post-title-link" itemprop="url">数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-05-27 20:36:30 / Modified: 20:47:43" itemprop="dateCreated datePublished" datetime="2021-05-27T20:36:30+08:00">2021-05-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>数据类型<br>谈到数据类型 可分为基本数据类型和引用数据类型</p>
</li>
<li><p>基本数据类型可分为<br>Number、String、Boolean、Null、Undefined、Symbol（ES6新增数据类型）bigInt</p>
</li>
<li><p>引用数据类型<br>Object、Array、Date、Function、RegExp</p>
</li>
</ul>
<p>其中基本数据类型的数据是直接存储在栈中；而引用数据类型的数据是存储在堆中，在栈中保存数据的引用地址，这个引用地址指向的是对应的数据，便于快速查找到堆内存中的对象。</p>
<p>栈内存是自动分配内存的，而堆内存是动态分配内存的，不会自动释放。因此每次使用完对象都要把它设置为null，从而减少无用内存的消耗，避免内存泄漏！</p>
<ul>
<li>判断数据类型的方式<br>typeof</li>
</ul>
<p>但是typeof null的值为Object，无法区分是null还是Object<br>tip:</p>
<p>因为在JavaScript中，不同的对象都是使用二进制存储的，如果二进制前三位都是0的话，系统会判断为是Object类型，而null的二进制全是0，自然也就判断为Object</p>
<p>扩展一下其他五种标识位：</p>
<p>000 对象<br>1 整型<br>010 双精度类型<br>100字符串<br>110布尔类型</p>
<p>instanceof</p>
<p>缺点：只能判断对象是否存在于目标对象的原型链上</p>
<p>constructor</p>
<p>Object.prototype.toString.call()</p>
<p>一种最好的基本类型检测方式 Object.prototype.toString.call() ;它可以区分 null 、 string 、</p>
<p>boolean 、 number 、 undefined 、 array 、 function 、 object 、 date 、 math 数据类型。</p>
<p>缺点：不能细分为关系之间的实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">  // -----------------------------------------typeof</span><br><span class="line">  typeof undefined // &#x27;undefined&#x27; </span><br><span class="line">  typeof &#x27;11&#x27; // &#x27;String&#x27; </span><br><span class="line">  typeof 11 // &#x27;Number&#x27; </span><br><span class="line">  typeof false // &#x27;Boolean&#x27; </span><br><span class="line">  typeof Symbol() // &#x27;Symbol&#x27; </span><br><span class="line">  typeof Function // ‘function&#x27; </span><br><span class="line">  typeof null // ‘Object’ </span><br><span class="line">  typeof [] // &#x27;Object&#x27; </span><br><span class="line">  typeof &#123;&#125; // &#x27;Object&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // -----------------------------------------instanceof</span><br><span class="line">  function Zoo() &#123; &#125;</span><br><span class="line">  var f1 = new Zoo();</span><br><span class="line">  var d = new Number(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  console.log(f1 instanceof Zoo);// true</span><br><span class="line">  console.log(d instanceof Number); //true</span><br><span class="line">  console.log(123 instanceof Number); //false   --&gt;不能判断字面量的基本数据类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // -----------------------------------------constructor</span><br><span class="line">  var d = new Number(1)</span><br><span class="line">  var e = 1</span><br><span class="line">  function fn() &#123;</span><br><span class="line">    console.log(&quot;Zing&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  var date = new Date();</span><br><span class="line">  var arr = [1, 2, 3];</span><br><span class="line">  var reg = /[hbc]at/gi;</span><br><span class="line"></span><br><span class="line">  console.log(e.constructor);//ƒ Number() &#123; [native code] &#125;</span><br><span class="line">  console.log(e.constructor.name);//Number</span><br><span class="line">  console.log(fn.constructor.name) // Function </span><br><span class="line">  console.log(date.constructor.name)// Date </span><br><span class="line">  console.log(arr.constructor.name) // Array </span><br><span class="line">  console.log(reg.constructor.name) // RegExp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //-----------------------------------------Object.prototype.toString.call()</span><br><span class="line">Object.prototype.toString(&#123;&#125;)       // &quot;[object Object]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也ok</span><br><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line">Object.prototype.toString.call(&#x27;1&#x27;)  // &quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;</span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;)  // &quot;[object Function]&quot;</span><br><span class="line">Object.prototype.toString.call(null)   //&quot;[object Null]&quot;</span><br><span class="line">Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;</span><br><span class="line">Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;</span><br><span class="line">Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;</span><br><span class="line">Object.prototype.toString.call([])       //&quot;[object Array]&quot;</span><br><span class="line">Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;</span><br><span class="line">Object.prototype.toString.call(window)   //&quot;[object Window]&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://lyyb.github.io/glennley.github.io/2021/05/27/array-unique/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/glennley.github.io/images/WechatIMG12.jpeg">
      <meta itemprop="name" content="GlennLey">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GlennLey's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/glennley.github.io/2021/05/27/array-unique/" class="post-title-link" itemprop="url">常见的数组去重方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-05-27 20:19:33 / Modified: 20:30:57" itemprop="dateCreated datePublished" datetime="2021-05-27T20:19:33+08:00">2021-05-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、利用ES6 Set去重（ES6中最常用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,2,2,2,2,3,4]</span><br><span class="line">       //  利用ES6 Set去重（ES6中最常用）</span><br><span class="line">       function unique (arr)&#123;</span><br><span class="line">           return Array.from(new Set(arr))</span><br><span class="line">       &#125;</span><br><span class="line">       console.log(unique(arr));</span><br></pre></td></tr></table></figure>
<p>不考虑兼容性，这种去重的方法代码量是最少的，但是这种方法无法去掉“{}”空对象。</p>
<p>二、利用for嵌套for，然后splice去重（ES5中最常用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">        for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            for (var j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                if (arr[i] == arr[j]) &#123;</span><br><span class="line">                    arr.splice(j, 1)</span><br><span class="line">                    j--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(unique(arr));</span><br></pre></td></tr></table></figure>

<p>三、利用indexOf去重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 利用indexOf去重</span><br><span class="line">       function unique (arr) &#123;</span><br><span class="line">           if (!Array.isArray(arr)) &#123;</span><br><span class="line">               console.log(&#x27;type error&#x27;);</span><br><span class="line">               return</span><br><span class="line">           &#125;</span><br><span class="line">           var array = []</span><br><span class="line">           for (var i = 0;i&lt;arr.length;i++) &#123;</span><br><span class="line">               if(array.indexOf(arr[i]) === -1)&#123;</span><br><span class="line">                   array.push(arr[i])</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return array</span><br><span class="line">       &#125;</span><br><span class="line">       console.log(unique(arr));</span><br></pre></td></tr></table></figure>

<p>四、利用对象属性去重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line"> if (!Array.isArray(arr)) &#123; </span><br><span class="line">     console.log(&#x27;type error!&#x27;) </span><br><span class="line">     return &#125; </span><br><span class="line">     let res = [], </span><br><span class="line">      obj = &#123;&#125; </span><br><span class="line">    for (let i = 0; i &lt; arr.length; i++) &#123; </span><br><span class="line">       if (!obj[arr[i]]) &#123;</span><br><span class="line">           res.push(arr[i]) obj[arr[i]] = 1</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">        obj[arr[i]]++ </span><br><span class="line">        &#125; &#125; </span><br><span class="line">        return res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://lyyb.github.io/glennley.github.io/2021/05/27/extends/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/glennley.github.io/images/WechatIMG12.jpeg">
      <meta itemprop="name" content="GlennLey">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GlennLey's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/glennley.github.io/2021/05/27/extends/" class="post-title-link" itemprop="url">常见的继承方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-05-27 20:12:23 / Modified: 20:18:32" itemprop="dateCreated datePublished" datetime="2021-05-27T20:12:23+08:00">2021-05-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>1.原型链继承</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.name = &#x27;glennley&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line"></span><br><span class="line">var child1 = new Child();</span><br><span class="line"></span><br><span class="line">console.log(child1.getName()) // glennley</span><br></pre></td></tr></table></figure>
<p>原型链继承方式中，引用类型的属性被所有实例共享</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names = [&#x27;glennley&#x27;, &#x27;daisy&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line"></span><br><span class="line">var child1 = new Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(&#x27;yayu&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1.names); </span><br><span class="line">// [&quot;glennley&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line"></span><br><span class="line">var child2 = new Child();</span><br><span class="line"></span><br><span class="line">console.log(child2.names); </span><br><span class="line">// [&quot;glennley&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br></pre></td></tr></table></figure>
<p>在创建 Child 的实例时，不能向Parent传参</p>
<ul>
<li>2.借用构造函数(经典继承)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names = [&#x27;glennley&#x27;, &#x27;daisy&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line">    Parent.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 = new Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(&#x27;yayu&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1.names); // [&quot;glennley&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line"></span><br><span class="line">var child2 = new Child();</span><br><span class="line"></span><br><span class="line">console.log(child2.names); // [&quot;glennley&quot;, &quot;daisy&quot;]</span><br></pre></td></tr></table></figure></li>
<li>优点：</li>
</ul>
<ol>
<li>避免了引用类型的属性被所有实例共享</li>
<li>可以在 Child 中向 Parent 传参</li>
<li>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 = new Child(&#x27;glennley&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1.name); // glennley</span><br><span class="line"></span><br><span class="line">var child2 = new Child(&#x27;daisy&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child2.name); // daisy</span><br></pre></td></tr></table></figure>

<ul>
<li>3、组合继承</li>
</ul>
<p>原理：使用原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承。<br>结合原型继承和构造函数的继承方法，对之进行优化，达到即可继承原型的方法，引用类型也不会被所有实例所共享。<br>原型链继承和经典继承结合体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line"></span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    </span><br><span class="line">    this.age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line">var child1 = new Child(&#x27;glennley&#x27;, &#x27;18&#x27;);</span><br><span class="line"></span><br><span class="line">child1.colors.push(&#x27;black&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1.name); // glennley</span><br><span class="line">console.log(child1.age); // 18</span><br><span class="line">console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class="line"></span><br><span class="line">var child2 = new Child(&#x27;daisy&#x27;, &#x27;20&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child2.name); // daisy</span><br><span class="line">console.log(child2.age); // 20</span><br><span class="line">console.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://lyyb.github.io/glennley.github.io/2021/05/27/promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/glennley.github.io/images/WechatIMG12.jpeg">
      <meta itemprop="name" content="GlennLey">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GlennLey's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/glennley.github.io/2021/05/27/promise/" class="post-title-link" itemprop="url">说说你对promise的理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-05-27 19:59:05 / Modified: 20:10:11" itemprop="dateCreated datePublished" datetime="2021-05-27T19:59:05+08:00">2021-05-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>围绕三个点 代理对象、三个状态、状态切换机制</strong></p>
<p>Promise 对象是一个代理对象。<br>它接受你传入的 executor（执行器）作为入参，<br>允许你把异步任务的成功和失败分别绑定到对应的处理方法上去。<br>一个 Promise 实例有三种状态</p>
<ul>
<li><p>pending 状态，表示进行中。这是 Promise 实例创建后的一个初始态；</p>
</li>
<li><p>fulfilled 状态，表示成功完成。这是我们在执行器中调用 resolve 后，<br>达成的状态；</p>
</li>
<li><p>rejected 状态，表示操作失败、被拒绝。<br>这是我们在执行器中调用 reject后，达成的状态；<br>Promise实例的状态是可以改变的，但它只允许被改变一次。<br>当我们的实例状态从 pending 切换为 rejected 后，<br>就无法再扭转为 fulfilled，反之同理。</p>
</li>
<li><p>当 Promise 的状态为 resolved 时<br>会触发其对应的 then 方法入参里的<br>onfulfilled 函数；当 Promise 的状态为 rejected 时，<br>会触发其对应的 then 方法入参里的 onrejected 函数。</p>
</li>
<li><p>Promise 常见方法有哪些？各自的作用？<br>all、race、reject 和 resolve。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var p1 = Promise.resolve(&#x27;1号选手&#x27;);</span><br><span class="line">var p2 = &#x27;2号选手&#x27;;</span><br><span class="line">var p3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(resolve, 100, &quot;3号选手&quot;);</span><br><span class="line">&#125;); </span><br><span class="line">Promise.all([p1, p2, p3]).then(values =&gt; &#123; </span><br><span class="line">  console.log(values); //  [&quot;1号选手&quot;, &quot;2号选手&quot;, &quot;3号选手&quot;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> Promise.race(iterable)<br> 当 iterable 参数里的任意一个子 promise 被成功或失败后，<br> 父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父<br> promise<br>绑定的相应处理函数，并返回该 promise 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(function(resolve, reject) &#123; </span><br><span class="line">    setTimeout(resolve, 100, &quot;1号选手&quot;); </span><br><span class="line">&#125;);</span><br><span class="line">var p2 = new Promise(function(resolve, reject) &#123; </span><br><span class="line">    setTimeout(resolve, 50, &quot;2号选手&quot;); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 这里因为 2 号选手返回得更早，所以返回值以 2号选手为准</span><br><span class="line">Promise.race([p1, p2]).then(function(value) &#123;</span><br><span class="line">  console.log(value); //  &quot;2号选手&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Promise.reject(reason)： 返回一个状态为失败的Promise对象并将给定的失败信息传递给对应的处理方法<br>Promise.resolve(value)：它返回一个 Promise 对象，但是这个对象的状态由你传入的value决定，情形分以下两种：<br>如果传入的是一个带有 then 方法的对象（我们称为 thenable 对象），返回的Promise对象的最终状态由then方法执行决定否则的话，返回的 Promise 对象状态为 fulfilled，<br>同时这里的 value 会作为 then 方法中指定的 onfulfilled 的入参</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve();</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(4);   // 1 2 4 3 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&#x27;第 1 次 resolve&#x27;)</span><br><span class="line">  console.log(&#x27;resolve后的普通逻辑&#x27;)</span><br><span class="line">  reject(&#x27;error&#x27;)</span><br><span class="line">  resolve(&#x27;第 2 次 resolve&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">promise</span><br><span class="line">.then((res) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;then: &#x27;, res)</span><br><span class="line">&#125;)</span><br><span class="line">.catch((err) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;catch: &#x27;, err)</span><br><span class="line">&#125;)     //resolve后的普通逻辑</span><br><span class="line">      // then:  第 1 次 resolve</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码里，promise 初始状态为 pending，我们在函数体第一行就用 resolve 把它置为了 fulfilled 态。这个切换完成后，后续所有尝试进一步作状态切换的动作全部不生效，<br>所以后续的 reject、resolve大家直接忽略掉就好；需要注意的是，我们忽略的是第一次 resolve 后的reject、resolve，而不是忽略它身后的所有代码。因此 console.log(‘resolve后的普通逻辑’) 这句<br>，仍然可以正常被执行。至于这里为啥它输出在 ”then:第 1 次 resolve“ 的前面，原因和真题1是一样一样的~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .then(Promise.resolve(2))</span><br><span class="line">  .then(3)</span><br><span class="line">  .then()</span><br><span class="line">  .then(console.log)</span><br></pre></td></tr></table></figure>
<p>then 方法里允许我们传入两个参数：onFulfilled（成功态的处理函数）和 onRejected（失败态的处理函数）。你可以两者都传，也可以只传前者或者后者。但是无论如何，then 方法的入参只能是函数。万一你想塞给它一些乱七八糟的东西，它就会“翻脸不认人”。<br>具体到我们这个题里，第一个 then 方法中传入的是一个 Promise 对象，then 说：”我不认识“；第二个 then 中传入的是一个数字， then 继续说”我不认识“；第四个干脆啥也没穿，then 说”入参undefined了，拜拜“；直到第五个入参，一个函数被传了进来，then 哭了：”终于等到一个我能处理的！“，于是只有最后一个入参生效了。在这个过程中，我们最初 resolve 出来那个值，<br>穿越了一个又一个无效的 then 调用，就好像是这些 then 调用都是透明的、不存在的一样，因此这种情形我们也形象地称它是 Promise 的“值穿透”。</p>
<p>简单的promise实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class PromiseModify &#123;</span><br><span class="line">        constructor(process) &#123;</span><br><span class="line">            this.status = &#x27;pending&#x27;</span><br><span class="line">            this.msg = &#x27;&#x27;</span><br><span class="line">            process(this.resolve.bind(this), this.reject.bind(this))</span><br><span class="line">            return this</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(val) &#123;</span><br><span class="line">            this.status = &#x27;fulfilled&#x27;</span><br><span class="line">            this.msg = val</span><br><span class="line">        &#125;</span><br><span class="line">        reject(err) &#123;</span><br><span class="line">            this.status = &#x27;rejected&#x27;</span><br><span class="line">            this.msg = err</span><br><span class="line">        &#125;</span><br><span class="line">        then(fulfilled, rejected) &#123;</span><br><span class="line">            if (this.status === &#x27;fulfilled&#x27;) &#123;</span><br><span class="line">                fulfilled(this.msg)</span><br><span class="line">            &#125;</span><br><span class="line">            if (this.status === &#x27;rejected&#x27;) &#123;</span><br><span class="line">                rejected(this.msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let ms = new PromiseModify((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(&#x27;123&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">    ms.then((success) =&gt; &#123;</span><br><span class="line">        console.log(success);</span><br><span class="line">    &#125;, (err) =&gt; &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/glennley.github.io/page/2/">2</a><a class="extend next" rel="next" href="/glennley.github.io/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GlennLey"
      src="/glennley.github.io/images/WechatIMG12.jpeg">
  <p class="site-author-name" itemprop="name">GlennLey</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/glennley.github.io/archives">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/glennley.github.io/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GlennLey</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/glennley.github.io/lib/anime.min.js"></script>
  <script src="/glennley.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/glennley.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/glennley.github.io/js/utils.js"></script>

<script src="/glennley.github.io/js/motion.js"></script>


<script src="/glennley.github.io/js/schemes/pisces.js"></script>


<script src="/glennley.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
